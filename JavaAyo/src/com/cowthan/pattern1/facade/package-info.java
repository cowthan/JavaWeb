/**
 * 	门面模式，又叫外观模式
 * 
 *  要求一个子系统的外部与其内部的通信必须通过一个统一的
 *  对象进行，门面模式提供一个高层次的接口，使得子系统
 *  更易于使用
 *  
 *  这个很简单，也就不敲代码了
 *  
 *  public class Facade{
 *  
 *    private A a = new A();
 *    private B b = new B();
 *    private C c = new C();
 *    
 *    public void func1(){}
 *    
 *    public void func2(){}
 *  }
 *  
 *  ——这里A，B，C三个类被看做是一个子系统，func1，func2提供的功能
 *  必须这三者配合完成，如果由外部直接访问这三个，就比较麻烦且不好扩展，
 *  所以这里Facade进行了统一的封装
 *  ——所以说这是一个很自然的模式，基本上你自己就会想到这样去封装起来
 *  
 *  
 *  门面模式的缺点在于：
 *  1、Facade这个类不能出问题，因为对其的任何修改都是对代码的直接修改，
 *  需要谨慎设计
 *  
 *  扩展：
 *  1、一个子系统多个门面，这一般是根据业务逻辑划分的
 *  例子：
 *  邮政系统：
 *  ——对于寄信者来说，你就提供收信人和邮件内容，至于由多少个对象来给你把
 *  这封信送到，这是送信子系统的事，不用你管
 *  ——对于收信者来说，你就去邮局报自己的名字就行了，或者查看自己的邮箱，至于
 *  是谁给你怎么送来的，你也不用关心
 *  
 *  用处：
 *  ——一个组员水平较差，就对他写的代码封装一个门面，让他烂在自己的代码里，
 *  对外部模块没有影响
 */
package com.cowthan.pattern1.facade;