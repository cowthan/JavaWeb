/**
 * 	装饰模式
 * 
 * 	动态的给一个对象添加一些额外的职责，就增加功能来说，装饰模式
 *  比生成子类更为灵活
 * 
 *  类似于代理，装饰类就是代理类，要去实现接口，但是：
 *  装饰类同时是个抽象类，必须被继承，每一个子类就是
 *  一种装饰效果，是一种对被装饰类的功能的扩展
 *  
 *  所以：
 *  继承：继承是静态的增加类的功能
 *  装饰：装饰是动态的增加类的功能
 *  
 *  实例：
 *  ——现在的这个例子不太好，但是也表现出了装饰模式的优点，可以动态的，组合的增强被代理对象的功能
 *  ——现在如果Son有些功能从Father继承下来了，并且传给了GrandSon，那要扩展Son的功能，可能就需要
 *  对GrandSon造成大量影响，所以还是要使用装饰模式
 *  ——现在不光要对Son的功能进行增强，这种增强还是灵活的，不固定的，多变的，那通过继承也解决不了，
 *  还是要通过装饰模式来解决。
 *  
 *  java的io就是典型的装饰模式，一个流包着另一个流，乱七八糟，你知道的
 */
package com.cowthan.pattern1.decorator;